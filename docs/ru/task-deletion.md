# Удаление задач и управление пулом TCB

## Обзор

Bedrock RTOS теперь поддерживает удаление задач через `br_task_delete()`, что позволяет удалять задачи из системы и возвращать их TCB (блоки управления задачами) в пул для повторного использования.

## Архитектура пула TCB

### Предыдущий дизайн (до удаления)

Изначально слоты TCB выделялись последовательно с помощью простого счетчика (`tcb_used`):
- Задачи создавались в слотах 0, 1, 2, ... до `CONFIG_MAX_TASKS`
- После выделения слоты никогда не освобождались
- Повторное использование TCB было невозможно

### Текущий дизайн (с поддержкой удаления)

Пул TCB теперь использует выделение на основе состояния:
- Каждый TCB имеет поле состояния (`BR_TASK_INACTIVE`, `BR_TASK_READY` и т.д.)
- `br_task_create()` сканирует первый слот в состоянии `BR_TASK_INACTIVE`
- `br_task_delete()` помечает слот как `BR_TASK_INACTIVE`, возвращая его в пул
- Слоты можно использовать повторно бесконечно

## API: `br_task_delete()`

### Сигнатура функции

```c
br_err_t br_task_delete(br_tid_t tid);
```

### Параметры

- `tid`: ID задачи для удаления

### Возвращаемые значения

- `BR_OK`: Задача успешно удалена
- `BR_ERR_INVALID`: Недопустимые условия:
  - ID задачи вне диапазона (`tid >= CONFIG_MAX_TASKS`)
  - Задача уже неактивна
  - Попытка удалить текущую выполняющуюся задачу

### Поведение

1. **Валидация**: Проверяет, является ли ID задачи корректным и существует ли задача
2. **Предотвращение самоудаления**: Нельзя удалить текущую выполняющуюся задачу
3. **Удаление из очереди**: Удаляет задачу из очереди готовых, если она там присутствует
4. **Очистка**: Очищает все поля TCB
5. **Возврат слота**: Помечает слот как `BR_TASK_INACTIVE` для повторного использования

### Важные ограничения

**Нельзя удалить выполняющуюся задачу**: Задача не может удалить саму себя. Для реализации самозавершения задачи:

```c
/* Из другой задачи */
void supervisor_task(void *arg) {
    br_tid_t worker_tid = get_worker_tid();
    
    /* Сигнал рабочей задаче завершиться */
    signal_worker_to_stop();
    
    /* Ждем, пока она отдаст управление или заблокируется */
    br_sleep_ms(10);
    
    /* Теперь безопасно удалять */
    br_task_delete(worker_tid);
}
```

## Примеры использования

### Базовое удаление задачи

```c
br_tid_t worker_tid;
static uint8_t worker_stack[512];

void worker_task(void *arg) {
    /* Выполняем работу */
    br_sleep_ms(100);
    /* Задача завершена, но остается в системе до удаления */
}

void main_task(void *arg) {
    /* Создаем рабочую задачу */
    br_task_create(&worker_tid, "worker", worker_task, NULL,
                   5, worker_stack, sizeof(worker_stack));
    
    /* Ждем завершения работы */
    br_sleep_ms(200);
    
    /* Удаляем рабочую задачу - слот можно использовать повторно */
    br_task_delete(worker_tid);
    
    /* Можем создать новую задачу в том же слоте */
    br_task_create(&worker_tid, "new_worker", another_task, NULL,
                   5, worker_stack, sizeof(worker_stack));
}
```

### Удаление приостановленных задач

```c
/* Приостанавливаем задачу */
br_task_suspend(worker_tid);

/* Удаляем в приостановленном состоянии */
br_task_delete(worker_tid);  /* OK - задача не выполняется */
```

### Удаление заблокированных задач

```c
/* Задача заблокирована на семафоре/мьютексе/сне */
br_task_delete(blocked_tid);  /* OK - задача не выполняется */
```

## Детали реализации

### Изменения в выделении TCB

**`br_task_create()` теперь ищет свободные слоты:**

```c
/* Поиск первого свободного слота TCB */
br_tcb_t *tcb = NULL;
for (int i = 0; i < CONFIG_MAX_TASKS; i++) {
    if (tcb_pool[i].state == BR_TASK_INACTIVE) {
        tcb = &tcb_pool[i];
        break;
    }
}
```

### Процесс очистки задачи

Когда задача удаляется:

```c
/* Удаляем из очереди готовых, если присутствует */
if (tcb->state == BR_TASK_READY) {
    br_sched_unready(tcb);
}

/* Очищаем все поля */
tcb->state = BR_TASK_INACTIVE;
tcb->name = NULL;
tcb->entry = NULL;
tcb->arg = NULL;
tcb->stack_base = NULL;
tcb->stack_size = 0;
tcb->stack_canary = NULL;
tcb->sp = NULL;
tcb->next = NULL;
```

## Лучшие практики

### Управление памятью

- **Время жизни стека**: Вызывающий должен гарантировать, что память стека остается действительной, пока существует задача
- **Повторное использование стека**: После удаления тот же буфер стека можно использовать для новых задач
- **Нет автоматической очистки**: Удаление задачи НЕ освобождает её стек - это ответственность вызывающего

### Безопасные паттерны удаления

**Паттерн 1: Супервизор управляет рабочими задачами**
```c
void supervisor(void *arg) {
    while (1) {
        br_tid_t worker;
        create_worker(&worker);
        wait_for_worker_completion(worker);
        br_task_delete(worker);  /* Очищаем после завершения */
    }
}
```

**Паттерн 2: Пул задач**
```c
#define POOL_SIZE 4
br_tid_t task_pool[POOL_SIZE];
uint8_t task_stacks[POOL_SIZE][TASK_STACK_SIZE];

void spawn_task(int slot, br_task_entry_t entry) {
    /* Удаляем старую задачу, если существует */
    if (task_pool[slot] != 0) {
        br_task_delete(task_pool[slot]);
    }
    
    /* Создаем новую задачу в слоте */
    br_task_create(&task_pool[slot], "pooled", entry, NULL,
                   5, task_stacks[slot], TASK_STACK_SIZE);
}
```

## Ограничения

1. **Нет самоудаления**: Задачи не могут удалять себя
2. **Нет автоматической очистки стека**: Вызывающий управляет памятью стека
3. **Нет отслеживания зависимостей**: Удаление задачи, владеющей мьютексом/ресурсом, требует ручной очистки
4. **Защита idle задачи**: Рассмотрите добавление защиты от удаления критически важных системных задач

## Будущие улучшения

Возможные улучшения:
- Добавить `br_task_exit()` для кооперативного самозавершения
- Хуки очистки ресурсов (автоматическое освобождение удерживаемых мьютексов/семафоров)
- Подсчет ссылок на задачи для предотвращения преждевременного удаления
- Состояние зомби для задач, которые завершились, но еще не были удалены

## Связанные API

- `br_task_create()`: Создание новых задач
- `br_task_suspend()`: Временная приостановка задачи
- `br_task_resume()`: Возобновление приостановленной задачи
- `br_task_yield()`: Добровольный отказ от процессора

## Ссылки

- `include/bedrock/bedrock.h`: Объявление публичного API
- `kernel/br_task.c`: Реализация
- `include/bedrock/br_types.h`: Определение структуры TCB
