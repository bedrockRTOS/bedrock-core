<!--
  Project: bedrock[RTOS]
  Version: 0.0.1
  Author:  AnmiTaliDev <anmitalidev@nuros.org>
  License: CC BY-SA 4.0
-->

# Руководство по портированию

Это руководство описывает, как добавить поддержку новой архитектуры или платы в bedrock[RTOS].

## Обзор

bedrock[RTOS] строго разделяет аппаратно-зависимый код и ядро. Для портирования необходимо:

1. Реализовать HAL-функции, объявленные в `include/bedrock/br_hal.h`
2. Предоставить файл стартового кода (таблица векторов, инициализация `.data`/`.bss`)
3. Предоставить скрипт линковки
4. Добавить цели сборки в `chorus.build`

Изменения в исходном коде ядра не требуются.

## Шаг 1: Создать каталог архитектуры

```
arch/<arch_name>/
├── br_hal_timer.c      Таймер и управление прерываниями
├── br_hal_context.c    Переключение контекста и инициализация стека
└── startup.c           Таблица векторов и Reset_Handler
```

## Шаг 2: Реализовать HAL таймера

```c
void br_hal_timer_init(void);
```

Инициализация аппаратного таймера. Должен обеспечить свободно работающий источник времени с разрешением не хуже микросекунды.

```c
br_time_t br_hal_timer_get_us(void);
```

Возвращает текущее время в микросекундах с момента загрузки. Должно быть монотонно возрастающим и корректно обрабатывать переполнение аппаратного счётчика.

```c
void br_hal_timer_set_alarm(br_time_t abs_us);
```

Установить одноразовый будильник на абсолютное время `abs_us`. При срабатывании вызвать `br_time_alarm_handler()` (объявлена в `bedrock/bedrock.h`).

```c
void br_hal_timer_cancel_alarm(void);
```

Отменить ожидающий будильник.

## Шаг 3: Реализовать HAL управления прерываниями

```c
uint32_t br_hal_irq_disable(void);
```

Глобально запретить прерывания. Вернуть предыдущее состояние для последующего восстановления.

```c
void br_hal_irq_restore(uint32_t state);
```

Восстановить состояние прерываний, возвращённое `br_hal_irq_disable()`.

```c
bool br_hal_in_isr(void);
```

Вернуть `true`, если выполнение происходит в контексте прерывания/исключения.

## Шаг 4: Реализовать HAL переключения контекста

```c
void *br_hal_stack_init(void *stack_top, br_task_entry_t entry, void *arg);
```

Сформировать начальный фрейм стека для новой задачи. Фрейм должен быть организован так, чтобы `br_hal_start_first_task()` или `br_hal_context_switch()` могли его восстановить и начать выполнение `entry(arg)`.

**Требования:**
- `stack_top` указывает на вершину (наивысший адрес) стека
- Возвращаемый указатель — начальный указатель стека (после формирования фрейма)
- Поле `sp` в TCB является **первым** членом структуры — ассемблерный код опирается на это

```c
void br_hal_context_switch(void **old_sp, void **new_sp);
```

Инициировать переключение контекста. Сохранить текущий контекст и записать указатель стека в `*old_sp`. Восстановить контекст из `*new_sp`.

На Cortex-M обычно выставляется PendSV вместо немедленного переключения.

```c
void br_hal_start_first_task(void *sp) __attribute__((noreturn));
```

Запустить выполнение первой задачи. Загрузить указатель стека `sp`, восстановить контекст и перейти к точке входа. Функция не должна возвращать управление.

## Шаг 5: Реализовать инициализацию платы

```c
void br_hal_board_init(void);
```

Ранняя инициализация платы (настройка тактирования, GPIO, периферия). Вызывается до инициализации таймера. Может быть пустой, если ничего не требуется.

## Шаг 6: Стартовый код

Предоставить `startup.c` (или `.s`) с:

- Таблицей векторов в секции `.isr_vector`
- `Reset_Handler`: копирование `.data` из flash в SRAM, обнуление `.bss`, вызов `main()`
- Обработчиками по умолчанию для исключений
- Записями для `PendSV_Handler` и `SysTick_Handler` (или эквивалентных)

## Шаг 7: Скрипт линковки

Создать `boards/<board_name>/linker.ld` с:

- Областями `MEMORY` для flash и RAM
- `ENTRY(Reset_Handler)`
- Секцией `.text` с `KEEP(*(.isr_vector))`
- Секцией `.data` с VMA в RAM, LMA во flash
- Секцией `.bss` в RAM
- Экспортом символов: `_sidata`, `_sdata`, `_edata`, `_sbss`, `_ebss`, `_estack`

## Шаг 8: Конфигурация сборки

Добавить цели компиляции и линковки для новой архитектуры в `chorus.build`.

## Справочная реализация

См. `arch/arm-cortex-m/` и `boards/qemu-cortex-m3/` — полный рабочий пример для QEMU LM3S6965 Cortex-M3.
