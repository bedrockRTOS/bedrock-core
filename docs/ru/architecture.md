<!--
  Project: bedrock[RTOS]
  Version: 0.0.1
  Author:  AnmiTaliDev <anmitalidev@nuros.org>
  License: CC BY-SA 4.0
-->

# Архитектура

## Обзор

bedrock[RTOS] — наноядерная операционная система реального времени. Это платформа, а не библиотека: ядро владеет процессом загрузки, планировщиком и уровнем аппаратной абстракции. Прикладной код выполняется в виде задач, управляемых ядром.

## Структура каталогов

```
bedrock-core/
├── kernel/              Планировщик, задачи, время, IPC
├── include/bedrock/     Публичные заголовочные файлы API
├── arch/                HAL-реализации для каждой архитектуры
│   └── arm-cortex-m/    Порт для ARM Cortex-M3
├── boards/              Скрипты линковки и конфиги для плат
│   └── qemu-cortex-m3/
├── lib/                 Статический аллокатор пулов, утилиты
├── examples/            Шаблоны приложений
├── docs/                Документация (EN / RU)
├── 3rd/tools/chorus     Система сборки (git submodule)
├── Kconfig              Конфигурация ядра
└── chorus.build         Конфигурация сборки
```

## Компоненты ядра

### Планировщик (`kernel/br_sched.c`)

Приоритетный вытесняющий планировщик с round-robin на одинаковых уровнях приоритета.

- `CONFIG_NUM_PRIORITIES` отдельных очередей готовности (по умолчанию 8), приоритет 0 — наивысший
- Задачи с одинаковым приоритетом планируются по round-robin (FIFO внутри очереди)
- Механизм блокировки/разблокировки планировщика для вложенных критических секций
- Переключение контекста через `br_hal_context_switch()` — на Cortex-M это вызывает PendSV

### Управление задачами (`kernel/br_task.c`)

Статический пул TCB — без динамического выделения памяти.

- До `CONFIG_MAX_TASKS` задач (по умолчанию 16)
- Каждая задача имеет: ID, имя, приоритет, стек, точку входа, состояние
- Состояния задач: `INACTIVE`, `READY`, `RUNNING`, `BLOCKED`, `SUSPENDED`
- Idle-задача создаётся автоматически с наименьшим приоритетом при вызове `br_kernel_init()`

### Временные сервисы (`kernel/br_time.c`)

Тиклесс-дизайн — без периодических прерываний таймера.

- 64-битные метки времени в микросекундах (`br_time_t` = `uint64_t`, диапазон ~584 000 лет)
- Список сна, отсортированный по времени пробуждения (по возрастанию)
- Аппаратный будильник перепрограммируется только при необходимости
- `br_time_alarm_handler()` пробуждает истёкшие задачи и вызывает перепланирование

### IPC (`kernel/br_ipc.c`)

Три примитива синхронизации:

- **Семафор** — счётный семафор с настраиваемым максимумом и очередью ожидания
- **Мьютекс** — бинарная блокировка с наследованием приоритета для предотвращения инверсии приоритетов
- **Очередь сообщений** — кольцевой буфер фиксированного размера с раздельными очередями ожидания на отправку/приём

Все очереди ожидания упорядочены по приоритету.

## Уровень аппаратной абстракции (HAL)

Ядро никогда не обращается к аппаратуре напрямую. Всё взаимодействие с платформой происходит через интерфейс HAL, объявленный в `include/bedrock/br_hal.h`.

### Функции HAL

| Категория | Функции |
|-----------|---------|
| Таймер | `br_hal_timer_init`, `br_hal_timer_get_us`, `br_hal_timer_set_alarm`, `br_hal_timer_cancel_alarm` |
| Прерывания | `br_hal_irq_disable`, `br_hal_irq_restore`, `br_hal_in_isr` |
| Контекст | `br_hal_stack_init`, `br_hal_context_switch`, `br_hal_start_first_task` |
| Плата | `br_hal_board_init` |

### Портирование

Для добавления новой архитектуры достаточно реализовать эти функции в `arch/<arch_name>/`. Изменения в ядре не требуются.

## Модель памяти

- Ноль `malloc` в ядре — все структуры выделяются статически
- Пул TCB: фиксированный массив из `CONFIG_MAX_TASKS` элементов
- Стеки: буферы, предоставляемые вызывающим кодом в `br_task_create()`
- Объекты IPC: объявляются как переменные (на стеке или глобально)
- Аллокатор пулов в `/lib`: опциональный, для выделения блоков фиксированного размера на уровне приложения

## Последовательность загрузки

1. `Reset_Handler` — копирует `.data`, обнуляет `.bss`, вызывает `main()`
2. `main()` вызывает `br_kernel_init()`:
   - Обнуляет пул TCB
   - Вызывает `br_hal_board_init()` и `br_hal_timer_init()`
   - Инициализирует планировщик
   - Создаёт idle-задачу
3. Приложение создаёт задачи через `br_task_create()`
4. `br_kernel_start()` — выбирает задачу с наивысшим приоритетом и запускает её (не возвращает управление)

## Переключение контекста (ARM Cortex-M)

- `br_hal_stack_init()` формирует начальный фрейм исключения: xPSR, PC, LR, R12, R3-R0 (аппаратный фрейм) + R4-R11 (сохраняемые программно)
- `br_hal_context_switch()` выставляет PendSV
- `PendSV_Handler` сохраняет/восстанавливает R4-R11 и переключает PSP между задачами
- `br_hal_start_first_task()` устанавливает PSP и переключается в thread mode
