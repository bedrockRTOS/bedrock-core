<!--
  Project: bedrock[RTOS]
  Version: 0.0.1
  Author:  AnmiTaliDev <anmitalidev@nuros.org>
  License: CC BY-SA 4.0
-->

# Справочник API

Все публичные функции и типы объявлены в `include/bedrock/bedrock.h`.

## Типы

### `br_time_t`

```c
typedef uint64_t br_time_t;
```

64-битная метка времени в микросекундах. Диапазон: ~584 000 лет.

**Константы:**

| Имя | Значение | Описание |
|-----|----------|----------|
| `BR_TIME_INFINITE` | `UINT64_MAX` | Ожидать бесконечно (без таймаута) |

**Макросы преобразования:**

| Макрос | Описание |
|--------|----------|
| `BR_USEC(us)` | Микросекунды в `br_time_t` |
| `BR_MSEC(ms)` | Миллисекунды в `br_time_t` |
| `BR_SEC(s)` | Секунды в `br_time_t` |

### `br_err_t`

```c
typedef enum {
    BR_OK            =  0,   // Успех
    BR_ERR_INVALID   = -1,   // Неверные параметры
    BR_ERR_NOMEM     = -2,   // Нет свободных ресурсов
    BR_ERR_TIMEOUT   = -3,   // Таймаут
    BR_ERR_BUSY      = -4,   // Ресурс занят
    BR_ERR_ISR       = -5,   // Вызов из ISR запрещён
    BR_ERR_OVERFLOW  = -6    // Переполнение
} br_err_t;
```

### `br_tid_t`

```c
typedef uint8_t br_tid_t;
```

Идентификатор задачи. Диапазон: от 0 до `CONFIG_MAX_TASKS - 1`.

### `br_task_entry_t`

```c
typedef void (*br_task_entry_t)(void *arg);
```

Сигнатура точки входа задачи. Функция получает указатель `arg`, переданный в `br_task_create()`.

## Жизненный цикл ядра

### `br_kernel_init`

```c
void br_kernel_init(void);
```

Инициализация ядра. Должна вызываться до любых других функций bedrock. Инициализирует HAL, планировщик и создаёт idle-задачу.

### `br_kernel_start`

```c
void br_kernel_start(void) __attribute__((noreturn));
```

Запуск планировщика. Выбирает задачу с наивысшим приоритетом и начинает выполнение. Никогда не возвращает управление.

## Управление задачами

### `br_task_create`

```c
br_err_t br_task_create(br_tid_t *tid,
                        const char *name,
                        br_task_entry_t entry,
                        void *arg,
                        uint8_t priority,
                        void *stack,
                        size_t stack_size);
```

Создание новой задачи.

**Параметры:**

| Параметр | Описание |
|----------|----------|
| `tid` | Выход: ID задачи (может быть `NULL`) |
| `name` | Имя задачи (хранится как указатель, не копируется) |
| `entry` | Функция точки входа задачи |
| `arg` | Аргумент, передаваемый в функцию входа |
| `priority` | Уровень приоритета (0 = наивысший, `CONFIG_NUM_PRIORITIES - 1` = наименьший) |
| `stack` | Указатель на буфер стека |
| `stack_size` | Размер буфера стека в байтах |

**Возвращает:** `BR_OK` при успехе, `BR_ERR_INVALID` при неверных параметрах, `BR_ERR_NOMEM` при переполнении пула TCB.

### `br_task_suspend`

```c
br_err_t br_task_suspend(br_tid_t tid);
```

Приостановка задачи. Задача удаляется из очереди готовности и не будет планироваться до вызова `br_task_resume()`.

**Возвращает:** `BR_OK` при успехе, `BR_ERR_INVALID` если `tid` вне диапазона.

### `br_task_resume`

```c
br_err_t br_task_resume(br_tid_t tid);
```

Возобновление ранее приостановленной задачи.

**Возвращает:** `BR_OK` при успехе, `BR_ERR_INVALID` если `tid` невалиден или задача не приостановлена.

### `br_task_yield`

```c
void br_task_yield(void);
```

Добровольная передача процессора. Текущая задача перемещается в конец своей очереди приоритета.

### `br_task_self`

```c
br_tid_t br_task_self(void);
```

Получить ID текущей выполняемой задачи.

## Временные сервисы

### `br_sleep_us`

```c
void br_sleep_us(br_time_t us);
```

Заблокировать текущую задачу минимум на `us` микросекунд. Если `us` равно 0, эквивалентно `br_task_yield()`.

### `br_sleep_ms`

```c
static inline void br_sleep_ms(uint32_t ms);
```

Заблокировать текущую задачу минимум на `ms` миллисекунд.

### `br_sleep_s`

```c
static inline void br_sleep_s(uint32_t s);
```

Заблокировать текущую задачу минимум на `s` секунд.

### `br_uptime_us`

```c
br_time_t br_uptime_us(void);
```

Получить время работы системы в микросекундах с момента загрузки.

## Семафор

### `br_sem_init`

```c
br_err_t br_sem_init(br_sem_t *sem, int32_t initial, int32_t max);
```

Инициализация счётного семафора.

**Параметры:**

| Параметр | Описание |
|----------|----------|
| `sem` | Указатель на объект семафора |
| `initial` | Начальное значение счётчика (>= 0 и <= `max`) |
| `max` | Максимальное значение счётчика (>= 1) |

**Возвращает:** `BR_OK` при успехе, `BR_ERR_INVALID` при неверных параметрах.

### `br_sem_take`

```c
br_err_t br_sem_take(br_sem_t *sem, br_time_t timeout);
```

Уменьшить семафор. Если счётчик равен 0, блокировать до освобождения или истечения таймаута. `0` — неблокирующая попытка, `BR_TIME_INFINITE` — ждать бесконечно.

**Возвращает:** `BR_OK` при успехе, `BR_ERR_TIMEOUT` если блокировка невозможна и `timeout` равен 0.

### `br_sem_give`

```c
br_err_t br_sem_give(br_sem_t *sem);
```

Увеличить семафор. Если есть ожидающие задачи, пробуждается задача с наивысшим приоритетом.

**Возвращает:** `BR_OK` при успехе, `BR_ERR_OVERFLOW` если счётчик превысит максимум.

## Мьютекс

Мьютексы поддерживают наследование приоритета: если высокоприоритетная задача блокируется на мьютексе, удерживаемом низкоприоритетной задачей, приоритет владельца временно повышается.

### `br_mutex_init`

```c
br_err_t br_mutex_init(br_mutex_t *mtx);
```

Инициализация мьютекса. Нельзя вызывать из ISR.

### `br_mutex_lock`

```c
br_err_t br_mutex_lock(br_mutex_t *mtx, br_time_t timeout);
```

Захват мьютекса. Если уже захвачен, блокировать до освобождения или таймаута.

**Возвращает:** `BR_OK` при успехе, `BR_ERR_TIMEOUT` при неблокирующем вызове, `BR_ERR_ISR` при вызове из ISR.

### `br_mutex_unlock`

```c
br_err_t br_mutex_unlock(br_mutex_t *mtx);
```

Освобождение мьютекса. Должен вызываться задачей-владельцем.

**Возвращает:** `BR_OK` при успехе, `BR_ERR_INVALID` если вызывающий не владелец, `BR_ERR_ISR` при вызове из ISR.

## Очередь сообщений

Кольцевой буфер фиксированного размера для межзадачного обмена. Буфер предоставляется вызывающим кодом.

### `br_mqueue_init`

```c
br_err_t br_mqueue_init(br_mqueue_t *mq, void *buffer,
                        size_t msg_size, size_t max_msgs);
```

Инициализация очереди сообщений.

**Параметры:**

| Параметр | Описание |
|----------|----------|
| `mq` | Указатель на объект очереди |
| `buffer` | Указатель на буфер хранения (`msg_size * max_msgs` байт) |
| `msg_size` | Размер одного сообщения в байтах |
| `max_msgs` | Максимальное количество сообщений |

### `br_mqueue_send`

```c
br_err_t br_mqueue_send(br_mqueue_t *mq, const void *msg, br_time_t timeout);
```

Отправить сообщение. Если очередь полна, блокировать до появления места или таймаута.

### `br_mqueue_recv`

```c
br_err_t br_mqueue_recv(br_mqueue_t *mq, void *msg, br_time_t timeout);
```

Принять сообщение. Если очередь пуста, блокировать до получения сообщения или таймаута.
